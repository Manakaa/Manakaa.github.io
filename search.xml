<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DongDong数颜色]]></title>
    <url>%2F2019%2F06%2F07%2FDongDong%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[#牛客练习赛 47 E DongDong 数颜色 补题网址 题目描述DongDong 是个喜欢数颜色的女孩子，她已经熟练地掌握了在序列上数颜色的操作，现在她开始学习如何在树上数颜色，现在给定一个 n 个点,n-1 条边的树形图（视 1 号店为根），每个点有一个颜色，每次询问以 x 为根的子树中有多少种不同的颜色，DongDong 轻松地解决了这个问题，但她想考考会编程的你。 输入描述:第一行两个整数 n,m 第二行 n 个整数，表示每个点的颜色 接下来 n-1 行每行 u,v,表示存在一条从 u 到 v 的双向边（保证最终图形是树形图） 2&lt;=n&lt;=100000,1&lt;=m,color&lt;=n，输出描述:共 m 行：每行输出相应询问的答案 示例 1:输入4 31 1 2 31 22 31 41 24 输出3 21 做法:典型的 dfs 序+莫队坑点：dfs 序之后需要改变原本数组的中的值的顺序，不然会错。比如将样例改为4 31 1 2 31 41 22 31 24 遍历之后的结果 4 这个节点是从 2 入从 2 出但是因为没有改变顺序所以计算的其实是 2 节点，这只是一个节点的情况试想一下如果 4 下面有子树呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 100010;int in[N], out[N], dfn, B[N], ans[N], Ans, color[N], c[N];int a[N], vis[N];vector&lt;int&gt; G[N];void dfs(int rt)&#123; in[rt] = ++dfn; vis[rt] = 1; for (int i = 0; i &lt; G[rt].size(); i++) &#123; if (!vis[G[rt][i]]) dfs(G[rt][i]); &#125; out[rt] = dfn;&#125;struct Query &#123; int l, r, ID;&#125;q[N];int main()&#123; int u, v; int n, m; scanf("%d %d", &amp;n, &amp;m); int unit = pow(n, 0.5); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), B[i] = i / unit + 1; for (int i = 1; i &lt; n; i++) &#123; scanf("%d %d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1); for (int i = 1; i &lt;= n; i++) c[in[i]] = a[i]; for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); q[i].l = in[x], q[i].r = out[x]; q[i].ID = i; &#125; sort(q + 1, q + m + 1, [](Query a, Query b) &#123; return B[a.l] == B[b.l] ? a.r &lt; b.r : a.l &lt; b.l; &#125;); int l = 1, r = 0; Ans = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &lt; q[i].l) &#123; color[c[l]]--; if (!color[c[l]]) Ans--; l++; &#125; while (l &gt; q[i].l) &#123; color[c[l - 1]]++; if (color[c[l - 1]] == 1) Ans++; l--; &#125; while (r &lt; q[i].r) &#123; color[c[r + 1]]++; if (color[c[r + 1]] == 1) Ans++; r++; &#125; while (r &gt; q[i].r) &#123; color[c[r]]--; if (!color[c[r]]) Ans--; r--; &#125; ans[q[i].ID] = Ans; &#125; for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", ans[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>dfs序</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balanced Numbers]]></title>
    <url>%2F2019%2F06%2F04%2FBalanced-Numbers%2F</url>
    <content type="text"><![CDATA[补题网址 题面： Balanced numbers have been used by mathematicians for centuries. A positive integer isconsidered a balanced number if: Every even digit appears an odd number of times in its decimal representation Every odd digit appears an even number oftimes in its decimal representation For example, 77, 211, 6222 and 112334445555677 arebalanced numbers while 351, 21, and 662 are not. Given an interval [A, B], your task is to find the amountof balanced numbers in [A, B] where both A and B are included. InputThe first line contains an integer T representing the number oftest cases.A test case consists of two numbers A and B separated by a singlespace representing the interval. You may assume that 1 &lt;= A &lt;= B &lt;= 1019 OutputFor each test case, you need to write a number in a single line:the amount of balanced numbers in the corresponding interval ExampleInput:2 1 10001 9Output:1474 题意：题目要求是求 l-r 之间满足每个偶数出现次数为奇数，每个奇数出现个数为偶数的数的个数正解是三进制，表示三种状态 00 未出现，01 出现奇数次， 10 出现偶数次。在这里我用的是二进制做的，前十位我用来表示 0-9 是否出现，后十位我用来表示 0-9 位出现次数最后 pos = 0 的时候 check 一下就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; #define ll long long int b[30]; ll dp[30][1 &lt;&lt; 20]; int updata(int state, int x) &#123; state |= (1 &lt;&lt; x); state ^= (1 &lt;&lt; (10 + x)); return state; &#125; ll check(int state) &#123; for (int i = 0; i &lt;= 9; i+=2) &#123; if ((state &gt;&gt; i &amp; 1) != (state &gt;&gt; (10 + i) &amp; 1)) return 0; if ((state &gt;&gt; (i + 1) &amp; 1) == 1 &amp;&amp; (state &gt;&gt; (10 + i + 1) &amp; 1) == 1) return 0; &#125; return 1; &#125; ll dfs(int pos, int state ,bool first, bool ismax) &#123; if (pos == 0) &#123; return check(state); &#125; if (!ismax &amp;&amp; dp[pos][state] != -1) return dp[pos][state]; int up = ismax ? b[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (!first || i != 0) ans += dfs(pos - 1, updata(state, i), first &amp;&amp; i == 0, ismax &amp;&amp; i == up); else ans += dfs(pos - 1, 0, first &amp;&amp; i == 0, ismax &amp;&amp; i == up); &#125; return ismax ? ans : dp[pos][state] = ans; &#125; ll slove(ll x) &#123; int pos = 0; while (x) &#123; b[++pos] = x % 10; x /= 10; &#125; return dfs(pos, 0, true, true); &#125; int main() &#123; int T; scanf("%d", &amp;T); ll n, m; memset(dp, -1, sizeof(dp)); while (T--) &#123; scanf("%lld %lld", &amp;n, &amp;m); printf("%lld\n", slove(m) - slove(n - 1)); &#125;return 0;&#125;]]></content>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
</search>
