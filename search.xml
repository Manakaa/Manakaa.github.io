<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KiKi's K-Number]]></title>
    <url>%2F2019%2F07%2F05%2FKiKi-s-K-Number%2F</url>
    <content type="text"><![CDATA[HDU 2852 KiKi’s K-Number补题网址 Problem DescriptionFor the k-th number, we all should be very familiar with it. Of course,to kiki it is also simple. Now Kiki meets a very similar problem, kiki wants to design a container, the container is to support the three operations. Push: Push a given element e to container Pop: Pop element of a given e from container Query: Given two elements a and k, query the kth larger number which greater than a in container; Although Kiki is very intelligent, she can not think of how to do it, can you help her to solve this problem? InputInput some groups of test data ,each test data the first number is an integer m (1 &lt;= m &lt;100000), means that the number of operation to do. The next m lines, each line will be an integer p at the beginning, p which has three values:If p is 0, then there will be an integer e (0 &lt;e &lt;100000), means press element e into Container. If p is 1, then there will be an integer e (0 &lt;e &lt;100000), indicated that delete the element e from the container If p is 2, then there will be two integers a and k (0 &lt;a &lt;100000, 0 &lt;k &lt;10000),means the inquiries, the element is greater than a, and the k-th larger number. OutputFor each deletion, if you want to delete the element which does not exist, the output “No Elment!”. For each query, output the suitable answers in line .if the number does not exist, the output “Not Find!”. Sample Input 5 0 5 1 2 0 6 2 3 2 2 8 1 7 0 2 0 2 0 4 2 1 1 2 1 2 2 1 3 2 1 4 Sample Output No Elment! 6 Not Find! 2 2 4 Not Find! 题意: 给出m个操作，第一种操作是加入一个数，第二种操作是删除一个数，第三种操作是查询比a大的第k个数字。 做法: 查询比a大的第k个数可以运用前缀和的思想，因为是需要动态添加删除所以使用树状数组,查询的时候二分结果就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1e5 + 7; int c[N]; int n; void update(int x, int k) &#123; for (int i = x; i &lt;= N; i += i &amp; (-i)) &#123; c[i] += k; &#125; &#125; int query(int x) &#123; int res = 0; for (int i = x; i &gt; 0; i -= i &amp; (-i)) res += c[i]; return res; &#125; int main() &#123; while (~scanf("%d", &amp;n)) &#123; memset(c, 0, sizeof(c)); for (int i = 1; i &lt;= n; i++) &#123; int pos, a, b; scanf("%d %d", &amp;pos, &amp;a); if (pos == 0) update(a, 1); else if (pos == 1) &#123; if (query(a) - query(a - 1) == 0) printf("No Elment!\n"); else update(a, -1); &#125; else &#123; scanf("%d", &amp;b); int y = query(a); int l = 0, r = N; while (l + 1 &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (query(mid) - y &gt;= b) r = mid; else l = mid; &#125; if (query(l) - y == b) r = l; if (r == N) printf("Not Find!\n"); else printf("%d\n", r); &#125; &#125; &#125; return 0; &#125;]]></content>
      <tags>
        <tag>二分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DongDong数颜色]]></title>
    <url>%2F2019%2F06%2F07%2FDongDong%E6%95%B0%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[#牛客练习赛 47 E DongDong 数颜色 补题网址 题目描述DongDong 是个喜欢数颜色的女孩子，她已经熟练地掌握了在序列上数颜色的操作，现在她开始学习如何在树上数颜色，现在给定一个 n 个点,n-1 条边的树形图（视 1 号店为根），每个点有一个颜色，每次询问以 x 为根的子树中有多少种不同的颜色，DongDong 轻松地解决了这个问题，但她想考考会编程的你。 输入描述:第一行两个整数 n,m 第二行 n 个整数，表示每个点的颜色 接下来 n-1 行每行 u,v,表示存在一条从 u 到 v 的双向边（保证最终图形是树形图） 2&lt;=n&lt;=100000,1&lt;=m,color&lt;=n，输出描述:共 m 行：每行输出相应询问的答案 示例 1:输入 4 3 1 1 2 3 1 2 2 3 1 4 1 2 4 输出 3 2 1 做法:典型的 dfs 序+莫队坑点：dfs 序之后需要改变原本数组的中的值的顺序，不然会错。比如将样例改为4 31 1 2 31 41 22 31 24 遍历之后的结果 4 这个节点是从 2 入从 2 出但是因为没有改变顺序所以计算的其实是 2 节点，这只是一个节点的情况试想一下如果 4 下面有子树呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt; using namespace std; const int N = 100010; int in[N], out[N], dfn, B[N], ans[N], Ans, color[N], c[N]; int a[N], vis[N]; vector&lt;int&gt; G[N]; void dfs(int rt) &#123; in[rt] = ++dfn; vis[rt] = 1; for (int i = 0; i &lt; G[rt].size(); i++) &#123; if (!vis[G[rt][i]]) dfs(G[rt][i]); &#125; out[rt] = dfn; &#125; struct Query &#123; int l, r, ID; &#125;q[N]; int main() &#123; int u, v; int n, m; scanf("%d %d", &amp;n, &amp;m); int unit = pow(n, 0.5); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), B[i] = i / unit + 1; for (int i = 1; i &lt; n; i++) &#123; scanf("%d %d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; dfs(1); for (int i = 1; i &lt;= n; i++) c[in[i]] = a[i]; for (int i = 1; i &lt;= m; i++) &#123; int x; scanf("%d", &amp;x); q[i].l = in[x], q[i].r = out[x]; q[i].ID = i; &#125; sort(q + 1, q + m + 1, [](Query a, Query b) &#123; return B[a.l] == B[b.l] ? a.r &lt; b.r : a.l &lt; b.l; &#125;); int l = 1, r = 0; Ans = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &lt; q[i].l) &#123; color[c[l]]--; if (!color[c[l]]) Ans--; l++; &#125; while (l &gt; q[i].l) &#123; color[c[l - 1]]++; if (color[c[l - 1]] == 1) Ans++; l--; &#125; while (r &lt; q[i].r) &#123; color[c[r + 1]]++; if (color[c[r + 1]] == 1) Ans++; r++; &#125; while (r &gt; q[i].r) &#123; color[c[r]]--; if (!color[c[r]]) Ans--; r--; &#125; ans[q[i].ID] = Ans; &#125; for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", ans[i]); &#125; return 0; &#125;]]></content>
      <tags>
        <tag>dfs序</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balanced Numbers]]></title>
    <url>%2F2019%2F06%2F04%2FBalanced-Numbers%2F</url>
    <content type="text"><![CDATA[补题网址 题面 Balanced numbers have been used by mathematicians for centuries. A positive integer isconsidered a balanced number if: Every even digit appears an odd number of times in its decimal representation Every odd digit appears an even number oftimes in its decimal representation For example, 77, 211, 6222 and 112334445555677 arebalanced numbers while 351, 21, and 662 are not. Given an interval [A, B], your task is to find the amountof balanced numbers in [A, B] where both A and B are included. InputThe first line contains an integer T representing the number oftest cases.A test case consists of two numbers A and B separated by a singlespace representing the interval. You may assume that 1 &lt;= A &lt;= B &lt;= 1019 OutputFor each test case, you need to write a number in a single line:the amount of balanced numbers in the corresponding interval ExampleInput:2 1 10001 9Output:1474 题意：题目要求是求 l-r 之间满足每个偶数出现次数为奇数，每个奇数出现个数为偶数的数的个数正解是三进制，表示三种状态 00 未出现，01 出现奇数次， 10 出现偶数次。在这里我用的是二进制做的，前十位我用来表示 0-9 是否出现，后十位我用来表示 0-9 位出现次数最后 pos = 0 的时候 check 一下就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; #define ll long long int b[30]; ll dp[30][1 &lt;&lt; 20]; int updata(int state, int x) &#123; state |= (1 &lt;&lt; x); state ^= (1 &lt;&lt; (10 + x)); return state; &#125; ll check(int state) &#123; for (int i = 0; i &lt;= 9; i+=2) &#123; if ((state &gt;&gt; i &amp; 1) != (state &gt;&gt; (10 + i) &amp; 1)) return 0; if ((state &gt;&gt; (i + 1) &amp; 1) == 1 &amp;&amp; (state &gt;&gt; (10 + i + 1) &amp; 1) == 1) return 0; &#125; return 1; &#125; ll dfs(int pos, int state ,bool first, bool ismax) &#123; if (pos == 0) &#123; return check(state); &#125; if (!ismax &amp;&amp; dp[pos][state] != -1) return dp[pos][state]; int up = ismax ? b[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (!first || i != 0) ans += dfs(pos - 1, updata(state, i), first &amp;&amp; i == 0, ismax &amp;&amp; i == up); else ans += dfs(pos - 1, 0, first &amp;&amp; i == 0, ismax &amp;&amp; i == up); &#125; return ismax ? ans : dp[pos][state] = ans; &#125; ll slove(ll x) &#123; int pos = 0; while (x) &#123; b[++pos] = x % 10; x /= 10; &#125; return dfs(pos, 0, true, true); &#125; int main() &#123; int T; scanf("%d", &amp;T); ll n, m; memset(dp, -1, sizeof(dp)); while (T--) &#123; scanf("%lld %lld", &amp;n, &amp;m); printf("%lld\n", slove(m) - slove(n - 1)); &#125; return 0; &#125;]]></content>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
</search>
