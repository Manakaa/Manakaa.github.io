<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Balanced Numbers]]></title>
    <url>%2F2019%2F06%2F04%2FBalanced-Numbers%2F</url>
    <content type="text"><![CDATA[补题网址题面： Balanced numbers have been used by mathematicians for centuries. A positive integer is considered a balanced number if: 1) Every even digit appears an odd number of times in its decimal representation 2) Every odd digit appears an even number of times in its decimal representation For example, 77, 211, 6222 and 112334445555677 are balanced numbers while 351, 21, and 662 are not. Given an interval [A, B], your task is to find the amount of balanced numbers in [A, B] where both A and B are included. Input The first line contains an integer T representing the number of test cases. A test case consists of two numbers A and B separated by a single space representing the interval. You may assume that 1 &lt;= A &lt;= B &lt;= 1019 Output For each test case, you need to write a number in a single line: the amount of balanced numbers in the corresponding interval Example Input: 2 1 1000 1 9 Output: 147 4 题意：题目要求是求 l-r 之间满足每个偶数出现次数为奇数，每个奇数出现个数为偶数的数的个数正解是三进制，表示三种状态 00 未出现，01 出现奇数次， 10 出现偶数次。在这里我用的是二进制做的，前十位我用来表示 0-9 是否出现，后十位我用来表示 0-9 位出现次数最后 pos = 0 的时候 check 一下就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; #define ll long long int b[30]; ll dp[30][1 &lt;&lt; 20]; int updata(int state, int x) &#123; state |= (1 &lt;&lt; x); state ^= (1 &lt;&lt; (10 + x)); return state; &#125; ll check(int state) &#123; for (int i = 0; i &lt;= 9; i+=2) &#123; if ((state &gt;&gt; i &amp; 1) != (state &gt;&gt; (10 + i) &amp; 1)) return 0; if ((state &gt;&gt; (i + 1) &amp; 1) == 1 &amp;&amp; (state &gt;&gt; (10 + i + 1) &amp; 1) == 1) return 0; &#125; return 1; &#125; ll dfs(int pos, int state ,bool first, bool ismax) &#123; if (pos == 0) &#123; return check(state); &#125; if (!ismax &amp;&amp; dp[pos][state] != -1) return dp[pos][state]; int up = ismax ? b[pos] : 9; ll ans = 0; for (int i = 0; i &lt;= up; i++) &#123; if (!first || i != 0) ans += dfs(pos - 1, updata(state, i), first &amp;&amp; i == 0, ismax &amp;&amp; i == up); else ans += dfs(pos - 1, 0, first &amp;&amp; i == 0, ismax &amp;&amp; i == up); &#125; return ismax ? ans : dp[pos][state] = ans; &#125; ll slove(ll x) &#123; int pos = 0; while (x) &#123; b[++pos] = x % 10; x /= 10; &#125; return dfs(pos, 0, true, true); &#125; int main() &#123; int T; scanf("%d", &amp;T); ll n, m; memset(dp, -1, sizeof(dp)); while (T--) &#123; scanf("%lld %lld", &amp;n, &amp;m); printf("%lld\n", slove(m) - slove(n - 1)); &#125;return 0;&#125;]]></content>
      <tags>
        <tag>数位DP</tag>
      </tags>
  </entry>
</search>
